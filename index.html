<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>MeinKraft - Space Edition</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: black;
            font-family: Arial, sans-serif;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 2000;
        }
        #loadingBar {
            width: 300px;
            height: 30px;
            background-color: #333;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 20px;
        }
        #loadingProgress {
            width: 0%;
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.3s;
        }
        #loadingText {
            margin-top: 10px;
            font-family: monospace;
        }
        #debug {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 1000;
        }
        #instructions {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 1000;
        }
        #hotbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
        .hotbar-item {
            width: 50px;
            height: 50px;
            border: 2px solid #666;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: border-color 0.3s;
        }
        .hotbar-item.selected {
            border-color: white;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <h2>Laddar Mars...</h2>
        <div id="loadingBar">
            <div id="loadingProgress"></div>
        </div>
        <div id="loadingText">Förbereder terräng...</div>
    </div>
    <canvas id="renderCanvas" touch-action="none"></canvas>
    <div id="debug">Loading...</div>
    <div id="instructions">
        WASD/Pilar = Rörelse<br>
        Mellanslag = Hoppa<br>
        Vänsterklick = Ta bort block<br>
        Högerklick = Placera block<br>
        1-6 = Välj block<br>
        ESC = Frigör muspekare
    </div>
    <div id="crosshair">+</div>
    <div id="hotbar"></div>
    
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script>
        // Konstanter för världen
        const WORLD_SIZE = 32;
        const CHUNK_SIZE = 16;
        const MAX_HEIGHT = 32;
        const SPAWN_HEIGHT = 10;
        const SPAWN_X = 0;
        const SPAWN_Z = 0;
        const baseHeight = 5;
        
        // Block typer för trollskogen
        const blockTypes = {
            GRASS: 'grass',
            DIRT: 'dirt',
            STONE: 'stone',
            TREE_TRUNK: 'tree_trunk',
            TREE_LEAVES: 'tree_leaves',
            FLOWER_RED: 'flower_red',
            FLOWER_YELLOW: 'flower_yellow',
            MUSHROOM: 'mushroom',
            TROLL_STONE: 'troll_stone',  // För förtrollade troll!
            MOSS: 'moss'                  // För extra atmosfär
        };
        
        // Blockfärger för sommarskog
        const blockColors = {
            [blockTypes.GRASS]: new BABYLON.Color3(0.4, 0.7, 0.3),      // Ljust grönt gräs
            [blockTypes.DIRT]: new BABYLON.Color3(0.4, 0.3, 0.2),       // Mörk jord
            [blockTypes.STONE]: new BABYLON.Color3(0.6, 0.6, 0.6),      // Grå sten
            [blockTypes.TREE_TRUNK]: new BABYLON.Color3(0.3, 0.2, 0.1), // Mörkt trä
            [blockTypes.TREE_LEAVES]: new BABYLON.Color3(0.3, 0.5, 0.2), // Mörkgröna löv
            [blockTypes.FLOWER_RED]: new BABYLON.Color3(0.8, 0.2, 0.2),  // Röda blommor
            [blockTypes.FLOWER_YELLOW]: new BABYLON.Color3(0.9, 0.8, 0.2), // Gula blommor
            [blockTypes.MUSHROOM]: new BABYLON.Color3(0.8, 0.4, 0.4),    // Rosa svamp
            [blockTypes.TROLL_STONE]: new BABYLON.Color3(0.5, 0.5, 0.55), // Trollsten (lite blåaktig)
            [blockTypes.MOSS]: new BABYLON.Color3(0.3, 0.4, 0.2)         // Mörk mossa
        };
        
        let blockCount = 0;
        const blockMeshes = {};
        const blockMaterials = {};
        
        function debugLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            const fullMessage = `${timestamp}: ${message}`;
            console.log(fullMessage);
            const debugElement = document.getElementById('debug');
            if (debugElement) {
                debugElement.innerHTML = fullMessage + '<br>' + debugElement.innerHTML;
                if (debugElement.innerHTML.split('<br>').length > 20) {
                    debugElement.innerHTML = debugElement.innerHTML.split('<br>').slice(0, 20).join('<br>');
                }
            }
        }
        
        // Blockera specifika felmeddelanden
        const originalConsoleError = console.error;
        console.error = function() {
            const errorMessage = Array.from(arguments).join(' ');
            if (errorMessage.includes('moz-extension') || 
                errorMessage.includes('Receiving end does not exist') ||
                errorMessage.includes('PHANTOM') ||
                errorMessage.includes('contentScript.js') ||
                errorMessage.includes('solanaActionsContentScript.js') ||
                errorMessage.includes('WEBGL_debug_renderer_info')) {
                return;
            }
            debugLog('ERROR: ' + errorMessage);
            originalConsoleError.apply(console, arguments);
        };
        
        // Hantera fel från Phantom extension
        window.onerror = function(message, source) {
            if (source && (source.includes('moz-extension') || 
                          source.includes('PHANTOM') || 
                          source.includes('contentScript.js') || 
                          source.includes('solanaActionsContentScript.js'))) {
                return true;
            }
        };
        
        // Hantera unhandled promise rejections
        window.onunhandledrejection = function(event) {
            if (event.reason && event.reason.message && 
                (event.reason.message.includes('moz-extension') || 
                 event.reason.message.includes('Receiving end does not exist') ||
                 event.reason.message.includes('PHANTOM'))) {
                event.preventDefault();
            }
        };
        
        // Uppdatera laddningsindikator
        function updateLoadingProgress(progress, text) {
            const progressBar = document.getElementById('loadingProgress');
            const loadingText = document.getElementById('loadingText');
            if (progressBar) {
                progressBar.style.width = `${progress}%`;
            }
            if (loadingText && text) {
                loadingText.textContent = text;
            }
        }

        // Dölj laddningsskärm
        function hideLoadingScreen() {
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen) {
                loadingScreen.style.display = 'none';
            }
        }

        // Starta spelet när sidan laddas
        window.addEventListener('load', async function() {
            try {
                debugLog('=== STARTAR TROLLSKOGEN ===');
                
                const canvas = document.getElementById('renderCanvas');
                const engine = new BABYLON.Engine(canvas, true);
                const scene = new BABYLON.Scene(engine);
                
                // Lägg till pointer lock variabel
                let isLocked = false;
                
                // Ljusblå sommarhimmel
                scene.clearColor = new BABYLON.Color4(0.6, 0.8, 1.0, 1);
                
                // Aktivera fysik och kollisioner
                scene.collisionsEnabled = true;
                scene.gravity = new BABYLON.Vector3(0, -9.81, 0);
                
                // Skapa starkt solljus för en sommardag
                const light = new BABYLON.HemisphericLight(
                    "sunLight",
                    new BABYLON.Vector3(0.2, 1, 0.3),
                    scene
                );
                light.intensity = 1.2;
                light.groundColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                
                // Lägg till lite dimma för mystisk känsla
                scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
                scene.fogDensity = 0.01;
                scene.fogColor = new BABYLON.Color3(0.8, 0.9, 1.0);
                
                debugLog('Miljö skapad');
                
                // Skapa kameran
                const camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(SPAWN_X, SPAWN_HEIGHT + 2, SPAWN_Z), scene);
                camera.setTarget(new BABYLON.Vector3(SPAWN_X + 1, SPAWN_HEIGHT + 2, SPAWN_Z + 1));
                camera.attachControl(canvas, true);
                camera.speed = 0.4;
                camera.fov = 1.2;
                camera.checkCollisions = true;
                camera.applyGravity = true;
                camera.ellipsoid = new BABYLON.Vector3(0.4, 1.8, 0.4);
                camera.ellipsoidOffset = new BABYLON.Vector3(0, 0.9, 0);
                camera.minZ = 0.1;
                camera.maxZ = 1000;
                camera.inertia = 0.3;
                camera.angularSensibility = 2000;

                // Sätt upp kontroller för WASD och piltangenter
                const keysForward = [87, 38];  // W och pil upp
                const keysBackward = [83, 40]; // S och pil ner
                const keysLeft = [65, 37];     // A och pil vänster 
                const keysRight = [68, 39];    // D och pil höger

                camera.keysUp = keysForward;
                camera.keysDown = keysBackward;
                camera.keysLeft = keysLeft;
                camera.keysRight = keysRight;

                // Sätt gravitationen för scenen
                scene.gravity = new BABYLON.Vector3(0, -0.65, 0);
                scene.collisionsEnabled = true;

                // Hantera hopp
                let canJump = true;
                window.addEventListener('keydown', function(evt) {
                    if (evt.code === 'Space' && canJump) {
                        camera.cameraDirection.y += 0.7;
                        canJump = false;
                        setTimeout(() => { canJump = true; }, 750);
                    }
                });
                
                // Skapa hotbar med block-typer
                const hotbar = document.getElementById('hotbar');
                let selectedBlockType = blockTypes.DIRT; // Standard block-typ
                
                // Lägg till block-typer i hotbar
                const hotbarBlocks = [
                    blockTypes.DIRT,
                    blockTypes.GRASS,
                    blockTypes.STONE,
                    blockTypes.TREE_TRUNK,
                    blockTypes.MOSS,
                    blockTypes.TROLL_STONE
                ];
                
                hotbarBlocks.forEach((type, index) => {
                    const item = document.createElement('div');
                    item.className = 'hotbar-item';
                    item.style.backgroundColor = `rgb(${blockColors[type].r * 255}, ${blockColors[type].g * 255}, ${blockColors[type].b * 255})`;
                    if (type === selectedBlockType) {
                        item.classList.add('selected');
                    }
                    item.addEventListener('click', () => {
                        document.querySelectorAll('.hotbar-item').forEach(i => i.classList.remove('selected'));
                        item.classList.add('selected');
                        selectedBlockType = type;
                    });
                    hotbar.appendChild(item);
                    
                    // Lägg till nummer-tangent som genväg (1-6)
                    window.addEventListener('keydown', (event) => {
                        if (event.key === String(index + 1)) {
                            document.querySelectorAll('.hotbar-item').forEach(i => i.classList.remove('selected'));
                            item.classList.add('selected');
                            selectedBlockType = type;
                        }
                    });
                });
                
                // Hantera musklick för att bygga/ta bort block
                scene.onPointerDown = function(evt) {
                    if (!isLocked) {
                        canvas.requestPointerLock = canvas.requestPointerLock || 
                                                  canvas.mozRequestPointerLock || 
                                                  canvas.webkitRequestPointerLock;
                        if (canvas.requestPointerLock) {
                            canvas.requestPointerLock();
                        }
                        return;
                    }
                    
                    const pickResult = scene.pick(
                        canvas.width / 2,  // Använd mitten av skärmen
                        canvas.height / 2,
                        null,
                        false,
                        camera
                    );
                    
                    if (!pickResult.hit) return;
                    
                    const pickedMesh = pickResult.pickedMesh;
                    if (!pickedMesh || !pickedMesh.blockType) return;
                    
                    if (evt.button === 0) { // Vänsterklick - ta bort block
                        const position = pickedMesh.position;
                        const key = `${Math.round(position.x)},${Math.round(position.y)},${Math.round(position.z)}`;
                        if (blockMeshes[key]) {
                            blockMeshes[key].dispose();
                            delete blockMeshes[key];
                        }
                    } else if (evt.button === 2) { // Högerklick - placera block
                        const point = pickResult.pickedPoint;
                        const normal = pickResult.getNormal();
                        const position = new BABYLON.Vector3(
                            Math.round(point.x + normal.x * 0.5),
                            Math.round(point.y + normal.y * 0.5),
                            Math.round(point.z + normal.z * 0.5)
                        );
                        
                        // Kontrollera att vi inte placerar block där spelaren står
                        const playerPos = camera.position;
                        const playerBlockPos = new BABYLON.Vector3(
                            Math.round(playerPos.x),
                            Math.round(playerPos.y),
                            Math.round(playerPos.z)
                        );
                        
                        if (!position.equals(playerBlockPos) && 
                            !position.equals(new BABYLON.Vector3(playerBlockPos.x, playerBlockPos.y - 1, playerBlockPos.z))) {
                            createBlock(position.x, position.y, position.z, selectedBlockType);
                        }
                    }
                };
                
                // Förhindra standardhögerklick-menyn
                canvas.addEventListener('contextmenu', function(evt) {
                    evt.preventDefault();
                });
                
                // Lyssna på pointer lock ändringar
                document.addEventListener("pointerlockchange", lockChangeAlert, false);
                document.addEventListener("mozpointerlockchange", lockChangeAlert, false);
                document.addEventListener("webkitpointerlockchange", lockChangeAlert, false);
                
                function lockChangeAlert() {
                    isLocked = document.pointerLockElement === canvas ||
                              document.mozPointerLockElement === canvas ||
                              document.webkitPointerLockElement === canvas;
                    
                    if (isLocked) {
                        debugLog("Muspekare låst");
                        camera.attachControl(canvas, true);
                    } else {
                        debugLog("Muspekare frigjord");
                        // Återställ alla rörelseflaggor när pointer lock släpps
                        moveForward = moveBackward = moveLeft = moveRight = false;
                        camera.detachControl(canvas);
                    }
                }
                
                // Hantera ESC-tangenten för att frigöra muspekaren
                window.addEventListener("keydown", function(evt) {
                    if (evt.keyCode === 27) { // ESC
                        if (isLocked) {
                            document.exitPointerLock = document.exitPointerLock ||
                                                     document.mozExitPointerLock ||
                                                     document.webkitExitPointerLock;
                            if (document.exitPointerLock) {
                                document.exitPointerLock();
                            }
                        }
                    }
                });
                
                // Funktion för att skapa ett block
                function createBlock(x, y, z, type) {
                    const key = `${x},${y},${z}`;
                    
                    const box = BABYLON.MeshBuilder.CreateBox(
                        `block_${key}`,
                        { size: 1 },
                        scene
                    );
                    box.position = new BABYLON.Vector3(x, y, z);
                    box.checkCollisions = true;
                    box.isPickable = true;
                    
                    // Skapa eller återanvänd material
                    let materialKey = `material_${type}`;
                    if (!blockMaterials[materialKey]) {
                        const material = new BABYLON.StandardMaterial(materialKey, scene);
                        material.diffuseColor = blockColors[type];
                        material.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                        
                        // Gör blommor och svampar delvis genomskinliga
                        if (type === blockTypes.FLOWER_RED || 
                            type === blockTypes.FLOWER_YELLOW || 
                            type === blockTypes.MUSHROOM) {
                            material.alpha = 0.8;
                        }
                        
                        blockMaterials[materialKey] = material;
                    }
                    
                    box.material = blockMaterials[materialKey];
                    box.blockType = type;
                    blockMeshes[key] = box;
                    blockCount++;
                    
                    if (blockCount % 100 === 0) {
                        debugLog(`Skapat ${blockCount} block`);
                    }
                    
                    return box;
                }
                
                // Hjälpfunktion för att skapa ett träd
                function createTree(x, y, z) {
                    const height = 4 + Math.floor(Math.random() * 3); // Trädhöjd 4-6 block
                    
                    // Skapa stam
                    for (let i = 0; i < height; i++) {
                        createBlock(x, y + i, z, blockTypes.TREE_TRUNK);
                    }
                    
                    // Skapa lövverk (som en boll)
                    for (let dx = -2; dx <= 2; dx++) {
                        for (let dy = -2; dy <= 2; dy++) {
                            for (let dz = -2; dz <= 2; dz++) {
                                // Skapa sfärisk form
                                if (dx*dx + dy*dy + dz*dz <= 8) {
                                    createBlock(
                                        x + dx,
                                        y + height - 1 + dy,
                                        z + dz,
                                        blockTypes.TREE_LEAVES
                                    );
                                }
                            }
                        }
                    }
                }
                
                // Hjälpfunktion för att skapa en blomma
                function createFlower(x, y, z) {
                    const type = Math.random() < 0.5 ? blockTypes.FLOWER_RED : blockTypes.FLOWER_YELLOW;
                    createBlock(x, y, z, type);
                }
                
                // Hjälpfunktion för att skapa en svamp
                function createMushroom(x, y, z) {
                    createBlock(x, y, z, blockTypes.MUSHROOM);
                }
                
                // Generera terräng för trollskogen
                debugLog('Skapar trollskog...');
                
                // Använd Simplex noise för att generera naturlig terräng
                function noise(x, z) {
                    return Math.sin(x * 0.1) * Math.cos(z * 0.1) * 2 + 
                           Math.sin(x * 0.05 + z * 0.05) * 3;
                }
                
                // Skapa terräng med träd och växter
                async function generateForest() {
                    const size = 16; // Storlek på skogen
                    
                    // Först skapar vi terrängen
                    for (let x = -size; x <= size; x++) {
                        for (let z = -size; z <= size; z++) {
                            // Beräkna höjd med noise
                            const height = Math.floor(baseHeight + noise(x, z));
                            
                            // Skapa markblock
                            for (let y = 0; y <= height; y++) {
                                const blockType = y === height ? blockTypes.GRASS :
                                                y > height - 3 ? blockTypes.DIRT :
                                                blockTypes.STONE;
                                createBlock(x, y, z, blockType);
                            }
                            
                            // Lägg till moss på vissa block
                            if (Math.random() < 0.1) {
                                createBlock(x, height, z, blockTypes.MOSS);
                            }
                            
                            // Placera träd med viss sannolikhet
                            if (Math.random() < 0.05 && 
                                Math.abs(x) > 2 && Math.abs(z) > 2) { // Inte för nära spawn
                                createTree(x, height + 1, z);
                            }
                            
                            // Placera blommor och svampar
                            if (Math.random() < 0.1) {
                                if (Math.random() < 0.7) {
                                    createFlower(x, height + 1, z);
                                } else {
                                    createMushroom(x, height + 1, z);
                                }
                            }
                            
                            // Placera några trollstenar
                            if (Math.random() < 0.02) {
                                const stoneHeight = Math.floor(1 + Math.random() * 2);
                                for (let h = 0; h < stoneHeight; h++) {
                                    createBlock(x, height + 1 + h, z, blockTypes.TROLL_STONE);
                                }
                            }
                            
                            await new Promise(resolve => setTimeout(resolve, 10));
                            scene.render();
                        }
                        
                        // Uppdatera laddningsprocent
                        const progress = ((x + size) / (size * 2)) * 100;
                        updateLoadingProgress(progress, `Skapar trollskog... ${Math.round(progress)}%`);
                    }
                }
                
                // Generera skogen
                await generateForest();
                debugLog('Trollskog skapad!');
                
                // Starta renderingsloopen
                engine.runRenderLoop(function() {
                    scene.render();
                });
                
                // Dölj laddningsskärmen
                hideLoadingScreen();
                
                window.addEventListener('resize', function() {
                    engine.resize();
                });
                
            } catch (error) {
                debugLog('ERROR: ' + error.message);
                console.error(error);
            }
        });
    </script>
</body>
</html>