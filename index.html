<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>MeinKraft - Space Edition</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: black;
            font-family: Arial, sans-serif;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            color: white;
            z-index: 2000;
        }
        #loadingBar {
            width: 300px;
            height: 30px;
            background-color: #333;
            border-radius: 15px;
            overflow: hidden;
            margin-top: 20px;
        }
        #loadingProgress {
            width: 0%;
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.3s;
        }
        #loadingText {
            margin-top: 10px;
            font-family: monospace;
        }
        #debug {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 1000;
        }
        #instructions {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 1000;
        }
        #hotbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
        .hotbar-item {
            width: 50px;
            height: 50px;
            border: 2px solid #666;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: border-color 0.3s;
        }
        .hotbar-item.selected {
            border-color: white;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            z-index: 1000;
        }
    </style>
</head>
<body>
    <div id="loadingScreen">
        <h2>Laddar Mars...</h2>
        <div id="loadingBar">
            <div id="loadingProgress"></div>
        </div>
        <div id="loadingText">Förbereder terräng...</div>
    </div>
    <canvas id="renderCanvas" touch-action="none"></canvas>
    <div id="debug">Loading...</div>
    <div id="instructions">
        WASD/Pilar = Rörelse<br>
        Mellanslag = Hoppa<br>
        Vänsterklick = Ta bort block<br>
        Högerklick = Placera block<br>
        1-6 = Välj block<br>
        ESC = Frigör muspekare
    </div>
    <div id="crosshair">+</div>
    <div id="hotbar"></div>
    
    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script>
        // Konstanter för världen
        const WORLD_SIZE = 32;
        const CHUNK_SIZE = 16;
        const MAX_HEIGHT = 32;
        const SPAWN_HEIGHT = 10;
        const SPAWN_X = 0;
        const SPAWN_Z = 0;
        const baseHeight = 5;
        
        // Block typer för trollskogen
        const blockTypes = {
            GRASS: 'grass',
            DIRT: 'dirt',
            STONE: 'stone',
            TREE_TRUNK: 'tree_trunk',
            TREE_LEAVES: 'tree_leaves',
            FLOWER_RED: 'flower_red',
            FLOWER_YELLOW: 'flower_yellow',
            MUSHROOM: 'mushroom',
            TROLL_STONE: 'troll_stone',  // För förtrollade troll!
            MOSS: 'moss'                  // För extra atmosfär
        };
        
        // Blockfärger för sommarskog
        const blockColors = {
            [blockTypes.GRASS]: new BABYLON.Color3(0.35, 0.6, 0.25),     // Mörkare, mer naturligt gräs
            [blockTypes.DIRT]: new BABYLON.Color3(0.35, 0.25, 0.15),     // Mörkare jord
            [blockTypes.STONE]: new BABYLON.Color3(0.6, 0.6, 0.6),       // Grå sten
            [blockTypes.TREE_TRUNK]: new BABYLON.Color3(0.6, 0.4, 0.2),  // Träfärg
            [blockTypes.TREE_LEAVES]: new BABYLON.Color3(0.3, 0.5, 0.2), // Löv
            [blockTypes.FLOWER_RED]: new BABYLON.Color3(0.8, 0.2, 0.2),  // Röda blommor
            [blockTypes.FLOWER_YELLOW]: new BABYLON.Color3(0.9, 0.8, 0.2), // Gula blommor
            [blockTypes.MUSHROOM]: new BABYLON.Color3(0.8, 0.4, 0.4),    // Rosa svamp
            [blockTypes.TROLL_STONE]: new BABYLON.Color3(0.5, 0.5, 0.55), // Trollsten
            [blockTypes.MOSS]: new BABYLON.Color3(0.3, 0.45, 0.2)        // Mörkare mossa
        };
        
        let blockCount = 0;
        const blockMeshes = {};
        const blockMaterials = {};
        
        function debugLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            const fullMessage = `${timestamp}: ${message}`;
            console.log(fullMessage);
            const debugElement = document.getElementById('debug');
            if (debugElement) {
                debugElement.innerHTML = fullMessage + '<br>' + debugElement.innerHTML;
                if (debugElement.innerHTML.split('<br>').length > 20) {
                    debugElement.innerHTML = debugElement.innerHTML.split('<br>').slice(0, 20).join('<br>');
                }
            }
        }
        
        // Blockera specifika felmeddelanden
        const originalConsoleError = console.error;
        console.error = function() {
            const errorMessage = Array.from(arguments).join(' ');
            if (errorMessage.includes('moz-extension') || 
                errorMessage.includes('Receiving end does not exist') ||
                errorMessage.includes('PHANTOM') ||
                errorMessage.includes('contentScript.js') ||
                errorMessage.includes('solanaActionsContentScript.js') ||
                errorMessage.includes('WEBGL_debug_renderer_info')) {
                return;
            }
            debugLog('ERROR: ' + errorMessage);
            originalConsoleError.apply(console, arguments);
        };
        
        // Hantera fel från Phantom extension
        window.onerror = function(message, source) {
            if (source && (source.includes('moz-extension') || 
                          source.includes('PHANTOM') || 
                          source.includes('contentScript.js') || 
                          source.includes('solanaActionsContentScript.js'))) {
                return true;
            }
        };
        
        // Hantera unhandled promise rejections
        window.onunhandledrejection = function(event) {
            if (event.reason && event.reason.message && 
                (event.reason.message.includes('moz-extension') || 
                 event.reason.message.includes('Receiving end does not exist') ||
                 event.reason.message.includes('PHANTOM'))) {
                event.preventDefault();
            }
        };
        
        // Uppdatera laddningsindikator
        function updateLoadingProgress(progress, text) {
            const progressBar = document.getElementById('loadingProgress');
            const loadingText = document.getElementById('loadingText');
            if (progressBar) {
                progressBar.style.width = `${progress}%`;
            }
            if (loadingText && text) {
                loadingText.textContent = text;
            }
        }

        // Dölj laddningsskärm
        function hideLoadingScreen() {
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen) {
                loadingScreen.style.display = 'none';
            }
        }

        // Starta spelet när sidan laddas
        window.addEventListener('load', async function() {
            try {
                debugLog('=== STARTAR TROLLSKOGEN ===');
                
                const canvas = document.getElementById('renderCanvas');
                const engine = new BABYLON.Engine(canvas, true);
                const scene = new BABYLON.Scene(engine);
                
                // Lägg till pointer lock variabel
                let isLocked = false;
                
                // Ljusblå sommarhimmel
                scene.clearColor = new BABYLON.Color4(0.6, 0.8, 1.0, 1);
                
                // Aktivera fysik och kollisioner
                scene.collisionsEnabled = true;
                scene.gravity = new BABYLON.Vector3(0, -9.81, 0);
                
                // Skapa starkt solljus för en sommardag
                const light = new BABYLON.HemisphericLight(
                    "sunLight",
                    new BABYLON.Vector3(0.2, 1, 0.3),
                    scene
                );
                light.intensity = 1.2;
                light.groundColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                
                // Lägg till lite dimma för mystisk känsla
                scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
                scene.fogDensity = 0.01;
                scene.fogColor = new BABYLON.Color3(0.8, 0.9, 1.0);
                
                debugLog('Miljö skapad');
                
                // Skapa kameran
                const camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(SPAWN_X, baseHeight + 2, SPAWN_Z), scene);
                camera.setTarget(new BABYLON.Vector3(SPAWN_X + 1, SPAWN_HEIGHT + 2, SPAWN_Z + 1));
                camera.attachControl(canvas, true);
                camera.speed = 0.4;
                camera.fov = 1.2;
                camera.checkCollisions = true;
                camera.applyGravity = true;
                camera.ellipsoid = new BABYLON.Vector3(0.4, 1.8, 0.4);  // Normal spelarhöjd (1.8 block)
                camera.ellipsoidOffset = new BABYLON.Vector3(0, 0.9, 0); // Centrera kollisionsboxen
                camera.minZ = 0.05;
                camera.maxZ = 1000;
                camera.inertia = 0.5;
                camera.angularSensibility = 1000;
                camera.stepHeight = 1.1;  // Gör det möjligt att gå över 1-block höga hinder

                // Sätt upp kontroller för WASD och piltangenter
                const keysForward = [87, 38];  // W och pil upp
                const keysBackward = [83, 40]; // S och pil ner
                const keysLeft = [65, 37];     // A och pil vänster 
                const keysRight = [68, 39];    // D och pil höger

                camera.keysUp = keysForward;
                camera.keysDown = keysBackward;
                camera.keysLeft = keysLeft;
                camera.keysRight = keysRight;

                // Sätt gravitationen för scenen
                scene.gravity = new BABYLON.Vector3(0, -0.65, 0);
                scene.collisionsEnabled = true;

                // Hantera hopp
                let canJump = true;
                let jumpVelocity = 0;
                window.addEventListener('keydown', function(evt) {
                    if (evt.code === 'Space' && canJump) {
                        jumpVelocity = 1.0;  // Sätt hopphastighet
                        canJump = false;
                        setTimeout(() => { canJump = true; }, 500);
                    }
                });

                // Uppdatera hopp och gravitation varje frame
                scene.registerBeforeRender(function() {
                    if (jumpVelocity > 0) {
                        camera.position.y += jumpVelocity;
                        jumpVelocity -= 0.05;  // Minska hopphastigheten gradvis
                    }
                });
                
                // Skapa hotbar med block-typer
                const hotbar = document.getElementById('hotbar');
                let selectedBlockType = blockTypes.DIRT; // Standard block-typ
                const crosshair = document.getElementById('crosshair');
                let isCmdPressed = false;

                // Lyssna på CMD-tangenten
                window.addEventListener('keydown', function(evt) {
                    if (evt.metaKey) {  // metaKey är CMD på Mac
                        isCmdPressed = true;
                        // Ändra crosshair-färgen till den valda blocktypen
                        const color = blockColors[selectedBlockType];
                        crosshair.style.color = `rgb(${color.r * 255}, ${color.g * 255}, ${color.b * 255})`;
                    }
                });

                window.addEventListener('keyup', function(evt) {
                    if (evt.key === 'Meta') {  // Meta är CMD på Mac
                        isCmdPressed = false;
                        crosshair.style.color = 'white';  // Återställ till vit
                    }
                });

                // Lägg till block-typer i hotbar
                const hotbarBlocks = [
                    blockTypes.DIRT,
                    blockTypes.GRASS,
                    blockTypes.STONE,
                    blockTypes.TREE_TRUNK,
                    blockTypes.MOSS,
                    blockTypes.TROLL_STONE
                ];
                
                hotbarBlocks.forEach((type, index) => {
                    const item = document.createElement('div');
                    item.className = 'hotbar-item';
                    item.style.backgroundColor = `rgb(${blockColors[type].r * 255}, ${blockColors[type].g * 255}, ${blockColors[type].b * 255})`;
                    if (type === selectedBlockType) {
                        item.classList.add('selected');
                    }
                    item.addEventListener('click', () => {
                        document.querySelectorAll('.hotbar-item').forEach(i => i.classList.remove('selected'));
                        item.classList.add('selected');
                        selectedBlockType = type;
                    });
                    hotbar.appendChild(item);
                    
                    // Lägg till nummer-tangent som genväg (1-6)
                    window.addEventListener('keydown', (event) => {
                        if (event.key === String(index + 1)) {
                            document.querySelectorAll('.hotbar-item').forEach(i => i.classList.remove('selected'));
                            item.classList.add('selected');
                            selectedBlockType = type;
                        }
                    });
                });
                
                // Uppdatera musklickhanteringen
                scene.onPointerDown = function(evt) {
                    if (!isLocked) {
                        canvas.requestPointerLock = canvas.requestPointerLock || 
                                                  canvas.mozRequestPointerLock || 
                                                  canvas.webkitRequestPointerLock;
                        if (canvas.requestPointerLock) {
                            canvas.requestPointerLock();
                        }
                        return;
                    }
                    
                    const pickResult = scene.pick(
                        canvas.width / 2,
                        canvas.height / 2,
                        (mesh) => mesh.checkCollisions,
                        false,
                        camera
                    );
                    
                    if (evt.button === 0) { // Vänsterklick
                        if (!isCmdPressed) {  // Ta bara bort block om CMD inte är intryckt
                            if (pickResult.hit && pickResult.pickedMesh && pickResult.pickedMesh.blockType) {
                                const position = pickResult.pickedMesh.position;
                                const key = `${Math.floor(position.x)},${Math.floor(position.y)},${Math.floor(position.z)}`;
                                if (blockMeshes[key]) {
                                    blockMeshes[key].dispose();
                                    delete blockMeshes[key];
                                    debugLog(`Block borttaget på ${key}`);
                                }
                            }
                        } else if (pickResult.hit) {  // Placera block om CMD är intryckt
                            const point = pickResult.pickedPoint;
                            const normal = pickResult.getNormal();
                            
                            // Beräkna den nya blockpositionen med bättre precision
                            const epsilon = 0.001;  // Liten offset för att undvika z-fighting
                            const newX = Math.round(point.x + normal.x * (0.5 + epsilon));
                            const newY = Math.round(point.y + normal.y * (0.5 + epsilon));
                            const newZ = Math.round(point.z + normal.z * (0.5 + epsilon));
                            
                            // Kontrollera avståndet till spelaren
                            const playerPos = camera.position;
                            const distanceToPlayer = BABYLON.Vector3.Distance(
                                new BABYLON.Vector3(newX, newY, newZ),
                                playerPos
                            );
                            
                            // Kontrollera att blocket inte är för nära eller för långt bort
                            if (distanceToPlayer > 1.5 && distanceToPlayer < 5) {
                                const playerBlockPos = {
                                    x: Math.round(playerPos.x),
                                    y: Math.round(playerPos.y),
                                    z: Math.round(playerPos.z)
                                };
                                
                                const playerHeadPos = {
                                    x: Math.round(playerPos.x),
                                    y: Math.round(playerPos.y + 1),
                                    z: Math.round(playerPos.z)
                                };
                                
                                // Kontrollera att vi inte placerar block där spelaren står
                                if (!(newX === playerBlockPos.x && newY === playerBlockPos.y && newZ === playerBlockPos.z) &&
                                    !(newX === playerHeadPos.x && newY === playerHeadPos.y && newZ === playerHeadPos.z)) {
                                    createBlock(newX, newY, newZ, selectedBlockType);
                                    debugLog(`Block placerat på ${newX},${newY},${newZ}`);
                                }
                            }
                        }
                    }
                };
                
                // Förhindra standardhögerklick-menyn
                canvas.addEventListener('contextmenu', function(evt) {
                    evt.preventDefault();
                });
                
                // Lyssna på pointer lock ändringar
                document.addEventListener("pointerlockchange", lockChangeAlert, false);
                document.addEventListener("mozpointerlockchange", lockChangeAlert, false);
                document.addEventListener("webkitpointerlockchange", lockChangeAlert, false);
                
                function lockChangeAlert() {
                    isLocked = document.pointerLockElement === canvas ||
                              document.mozPointerLockElement === canvas ||
                              document.webkitPointerLockElement === canvas;
                    
                    if (isLocked) {
                        debugLog("Muspekare låst");
                        camera.attachControl(canvas, true);
                    } else {
                        debugLog("Muspekare frigjord");
                        // Återställ alla rörelseflaggor när pointer lock släpps
                        moveForward = moveBackward = moveLeft = moveRight = false;
                        camera.detachControl(canvas);
                    }
                }
                
                // Hantera ESC-tangenten för att frigöra muspekaren
                window.addEventListener("keydown", function(evt) {
                    if (evt.keyCode === 27) { // ESC
                        if (isLocked) {
                            document.exitPointerLock = document.exitPointerLock ||
                                                     document.mozExitPointerLock ||
                                                     document.webkitExitPointerLock;
                            if (document.exitPointerLock) {
                                document.exitPointerLock();
                            }
                        }
                    }
                });
                
                // Funktion för att skapa ett block
                function createBlock(x, y, z, type) {
                    const key = `${x},${y},${z}`;
                    
                    const box = BABYLON.MeshBuilder.CreateBox(
                        `block_${key}`,
                        { size: 1 },
                        scene
                    );
                    box.position = new BABYLON.Vector3(x, y, z);
                    box.checkCollisions = true;
                    box.isPickable = true;
                    
                    // Skapa eller återanvänd material
                    let materialKey = `material_${type}`;
                    if (!blockMaterials[materialKey]) {
                        const material = new BABYLON.StandardMaterial(materialKey, scene);
                        material.diffuseColor = blockColors[type];
                        material.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                        
                        // Lägg till textur för trädens löv
                        if (type === blockTypes.TREE_LEAVES) {
                            const leavesTexture = new BABYLON.Texture("src/textures/tree.png", scene);
                            material.diffuseTexture = leavesTexture;
                            material.diffuseTexture.hasAlpha = false;
                            material.backFaceCulling = false;
                            material.specularColor = new BABYLON.Color3(0, 0, 0);  // Ingen glans
                            material.ambientColor = new BABYLON.Color3(0.4, 0.6, 0.3);  // Ljusare grundfärg
                            material.emissiveColor = new BABYLON.Color3(0.1, 0.15, 0.05);  // Svag självlysande effekt för kontrast
                            material.useLogarithmicDepth = true;  // Bättre djuprendering
                        }
                        
                        // Lägg till barktextur för trädstammar
                        if (type === blockTypes.TREE_TRUNK) {
                            const barkTexture = new BABYLON.Texture("src/textures/tree2.png", scene);
                            material.diffuseTexture = barkTexture;
                            material.diffuseTexture.hasAlpha = false;
                            material.backFaceCulling = false;
                            material.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);  // Mindre glans
                            material.ambientColor = new BABYLON.Color3(0.6, 0.4, 0.2);   // Ljusare grundfärg
                            material.emissiveColor = new BABYLON.Color3(0.1, 0.05, 0);   // Svag varm glöd
                        }
                        
                        // Gör blommor och svampar delvis genomskinliga
                        if (type === blockTypes.FLOWER_RED || 
                            type === blockTypes.FLOWER_YELLOW || 
                            type === blockTypes.MUSHROOM) {
                            material.alpha = 0.8;
                        }
                        
                        blockMaterials[materialKey] = material;
                    }
                    
                    box.material = blockMaterials[materialKey];
                    box.blockType = type;
                    blockMeshes[key] = box;
                    blockCount++;
                    
                    if (blockCount % 100 === 0) {
                        debugLog(`Skapat ${blockCount} block`);
                    }
                    
                    return box;
                }
                
                // Hjälpfunktion för att skapa ett träd
                function createTree(x, y, z) {
                    const height = 4 + Math.floor(Math.random() * 3); // Trädhöjd 4-6 block
                    
                    // Kontrollera om platsen är ledig för ett träd
                    for (let i = 0; i < height; i++) {
                        const key = `${x},${y + i},${z}`;
                        if (blockMeshes[key]) {
                            return false; // Platsen är upptagen
                        }
                    }
                    
                    // Skapa stam
                    for (let i = 0; i < height; i++) {
                        createBlock(x, y + i, z, blockTypes.TREE_TRUNK);
                    }
                    
                    // Skapa lövverk (som en naturlig krona)
                    const leafStart = height - 3;  // Börja lövverket 3 block från toppen
                    
                    // Skapa en mer naturlig trädkrona
                    for (let dy = 0; dy < 4; dy++) {  // 4 nivåer av löv
                        const radius = dy === 1 || dy === 2 ? 2 : 1;  // Större radie i mitten
                        
                        for (let dx = -radius; dx <= radius; dx++) {
                            for (let dz = -radius; dz <= radius; dz++) {
                                // Skapa en mer naturlig, rundad form
                                if (dx*dx + dz*dz <= radius*radius + 0.5) {
                                    const leafX = x + dx;
                                    const leafY = y + leafStart + dy;
                                    const leafZ = z + dz;
                                    
                                    // Lägg till lite slumpmässighet för att göra det mer naturligt
                                    if (Math.random() > 0.1) {  // 90% chans att placera ett löv
                                        const leafKey = `${leafX},${leafY},${leafZ}`;
                                        if (!blockMeshes[leafKey]) {
                                            createBlock(leafX, leafY, leafZ, blockTypes.TREE_LEAVES);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    // Lägg till några extra löv för att göra kronan mer oregelbunden
                    for (let i = 0; i < 5; i++) {
                        const dx = Math.floor(Math.random() * 5) - 2;
                        const dy = Math.floor(Math.random() * 2);
                        const dz = Math.floor(Math.random() * 5) - 2;
                        
                        const leafX = x + dx;
                        const leafY = y + leafStart + dy;
                        const leafZ = z + dz;
                        
                        const leafKey = `${leafX},${leafY},${leafZ}`;
                        if (!blockMeshes[leafKey]) {
                            createBlock(leafX, leafY, leafZ, blockTypes.TREE_LEAVES);
                        }
                    }
                    
                    return true;
                }
                
                // Hjälpfunktion för att skapa en blomma
                function createFlower(x, y, z) {
                    const type = Math.random() < 0.5 ? blockTypes.FLOWER_RED : blockTypes.FLOWER_YELLOW;
                    createBlock(x, y, z, type);
                }
                
                // Hjälpfunktion för att skapa en svamp
                function createMushroom(x, y, z) {
                    createBlock(x, y, z, blockTypes.MUSHROOM);
                }
                
                // Generera terräng för trollskogen
                debugLog('Skapar trollskog...');
                
                // Använd Simplex noise för att generera naturlig terräng
                function noise(x, z) {
                    return Math.sin(x * 0.1) * Math.cos(z * 0.1) * 2 + 
                           Math.sin(x * 0.05 + z * 0.05) * 3;
                }
                
                // Skapa terräng med träd och växter
                async function generateForest() {
                    const size = 16; // Storlek på skogen
                    
                    // Först skapar vi terrängen
                    for (let x = -size; x <= size; x++) {
                        for (let z = -size; z <= size; z++) {
                            // Beräkna höjd med noise
                            const height = Math.floor(baseHeight + noise(x, z));
                            
                            // Skapa markblock
                            for (let y = 0; y <= height; y++) {
                                const blockType = y === height ? blockTypes.GRASS :
                                                y > height - 3 ? blockTypes.DIRT :
                                                blockTypes.STONE;
                                createBlock(x, y, z, blockType);
                            }
                            
                            // Lägg till moss på vissa block (minskat sannolikheten)
                            if (Math.random() < 0.05) {  // Ändrat från 0.1 till 0.05
                                createBlock(x, height, z, blockTypes.MOSS);
                            }
                            
                            // Placera träd med viss sannolikhet
                            if (Math.random() < 0.05 && 
                                Math.abs(x) > 3 && Math.abs(z) > 3) {
                                // Kontrollera närliggande block för att undvika träd för nära varandra
                                let canPlaceTree = true;
                                for (let dx = -2; dx <= 2; dx++) {
                                    for (let dz = -2; dz <= 2; dz++) {
                                        const nearbyKey = `${x + dx},${height + 1},${z + dz}`;
                                        if (blockMeshes[nearbyKey]) {
                                            canPlaceTree = false;
                                            break;
                                        }
                                    }
                                }
                                if (canPlaceTree) {
                                    createTree(x, height + 1, z);
                                }
                            }
                            
                            // Placera blommor och svampar mer sällan
                            if (Math.random() < 0.03) {  // Ändrat från 0.1 till 0.03
                                if (Math.random() < 0.7) {
                                    createFlower(x, height + 1, z);
                                } else {
                                    createMushroom(x, height + 1, z);
                                }
                            }
                            
                            // Placera några trollstenar
                            if (Math.random() < 0.02) {
                                const stoneHeight = Math.floor(1 + Math.random() * 2);
                                for (let h = 0; h < stoneHeight; h++) {
                                    createBlock(x, height + 1 + h, z, blockTypes.TROLL_STONE);
                                }
                            }
                            
                            await new Promise(resolve => setTimeout(resolve, 10));
                            scene.render();
                        }
                        
                        // Uppdatera laddningsprocent
                        const progress = ((x + size) / (size * 2)) * 100;
                        updateLoadingProgress(progress, `Skapar trollskog... ${Math.round(progress)}%`);
                    }
                }
                
                // Generera skogen
                await generateForest();
                debugLog('Trollskog skapad!');
                
                // Starta renderingsloopen
                engine.runRenderLoop(function() {
                    scene.render();
                });
                
                // Dölj laddningsskärmen
                hideLoadingScreen();
                
                window.addEventListener('resize', function() {
                    engine.resize();
                });
                
            } catch (error) {
                debugLog('ERROR: ' + error.message);
                console.error(error);
            }
        });
    </script>
</body>
</html>