<!DOCTYPE html>
<html>
<head>
    <meta charset="UTF-8">
    <title>Cubelure - Space Edition</title>
    <style>
        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: black;
            font-family: Arial, sans-serif;
        }
        #renderCanvas {
            width: 100%;
            height: 100%;
            touch-action: none;
        }
        #loadingScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.8);
        }
        #logo {
            position: absolute;
            top: 40%;
            left: 50%;
            transform: translate(-50%, -50%);
            max-width: 300px;
        }
        #loadingBar {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 300px;
            height: 20px;
            background-color: rgba(51, 51, 51, 0.8);
            border-radius: 10px;
            overflow: hidden;
        }
        #loadingProgress {
            width: 0%;
            height: 100%;
            background-color: #4CAF50;
            transition: width 0.3s;
        }
        #loadingText {
            position: absolute;
            top: 55%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-family: monospace;
            font-size: 14px;
            color: rgba(255, 255, 255, 0.8);
        }
        #debug {
            position: fixed;
            top: 10px;
            right: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 1000;
            max-width: 300px;
            max-height: 200px;
            overflow-y: auto;
            word-wrap: break-word;
        }
        #instructions {
            position: fixed;
            top: 10px;
            left: 10px;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            padding: 10px;
            border-radius: 5px;
            font-family: monospace;
            z-index: 1000;
        }
        #hotbar {
            position: fixed;
            bottom: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            gap: 5px;
            background: rgba(0, 0, 0, 0.7);
            padding: 10px;
            border-radius: 5px;
            z-index: 1000;
        }
        .hotbar-item {
            width: 50px;
            height: 50px;
            border: 2px solid #666;
            border-radius: 5px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: border-color 0.3s;
            background-size: cover;
            background-position: center;
            image-rendering: pixelated;
        }
        .hotbar-item.selected {
            border-color: white;
        }
        #crosshair {
            position: fixed;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            pointer-events: none;
            z-index: 1000;
            display: none;
        }
        #diamondCounter {
            position: fixed;
            top: 20px;
            left: 50%;
            transform: translateX(-50%);
            display: flex;
            align-items: center;
            gap: 10px;
            background-color: rgba(0, 0, 0, 0.5);
            padding: 5px 15px;
            border-radius: 5px;
            z-index: 1000;
        }
        
        #diamondIcon {
            width: 32px;
            height: 32px;
            image-rendering: pixelated;
        }
        
        #diamondCount {
            color: white;
            font-size: 24px;
            font-family: 'Minecraft', monospace;
        }
        
        #startScreen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: rgba(0, 0, 0, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: flex-start;
            align-items: center;
            z-index: 2000;
        }
        
        #startScreen img.logo {
            max-width: 300px;
            margin-top: 20vh;
            margin-bottom: 0;
        }
        
        #startButton {
            background: none;
            border: none;
            cursor: pointer;
            transition: transform 0.2s;
            padding: 0;
            margin-top: -80px;
        }
        
        #startButton img {
            max-width: 150px;
            image-rendering: pixelated;
        }
        
        #startButton:hover {
            transform: scale(1.1);
        }
    </style>
</head>
<body>
    <div id="startScreen">
        <img class="logo" src="src/images/logo.png" alt="Cubelure Logo">
        <button id="startButton">
            <img src="src/images/start.png" alt="Start Game">
        </button>
    </div>
    
    <div id="loadingScreen">
        <img id="logo" src="src/images/logo.png" alt="Game Logo">
        <div id="loadingBar">
            <div id="loadingProgress"></div>
        </div>
        <div id="loadingText">Preparing world...</div>
    </div>
    <canvas id="renderCanvas" touch-action="none"></canvas>
    <div id="debug">Loading...</div>
    <div id="instructions">
        WASD/Arrows = Move<br>
        Space = Jump<br>
        Left Click = Remove block<br>
        Right Click = Place block<br>
        1-6 = Select block<br>
        ESC = Release mouse
    </div>
    <div id="crosshair">+</div>
    <div id="hotbar"></div>
    <div id="diamondCounter">
        <img id="diamondIcon" src="src/textures/diamond.png" alt="Diamond">
        <span id="diamondCount">0</span>
    </div>

    <script src="https://cdn.babylonjs.com/babylon.js"></script>
    <script>
        // Konstanter för världen
        const WORLD_SIZE = 32;
        const CHUNK_SIZE = 16;
        const MAX_HEIGHT = 32;
        const SPAWN_HEIGHT = 10;
        const SPAWN_X = 0;
        const SPAWN_Z = 0;
        const baseHeight = 5;
        
        // Block typer för världen
        const blockTypes = {
            GRASS: 'grass',
            DIRT: 'dirt',
            STONE: 'stone',
            TREE_TRUNK: 'tree_trunk',
            TREE_LEAVES: 'tree_leaves',
            FLOWER_RED: 'flower_red',
            FLOWER_YELLOW: 'flower_yellow',
            FLOWER_PURPLE: 'flower_purple',
            MUSHROOM: 'mushroom',
            STONE_SPECIAL: 'stone_special',  // Changed from TROLL_STONE
            MOSS: 'moss',
            CLOUD: 'cloud',
            SUN: 'sun',
            DIAMOND: 'diamond'  // Ny blocktyp
        };
        
        // Blockfärger för sommarskog
        const blockColors = {
            [blockTypes.GRASS]: new BABYLON.Color3(0.35, 0.6, 0.25),
            [blockTypes.DIRT]: new BABYLON.Color3(0.35, 0.25, 0.15),
            [blockTypes.STONE]: new BABYLON.Color3(0.6, 0.6, 0.6),
            [blockTypes.TREE_TRUNK]: new BABYLON.Color3(0.6, 0.4, 0.2),
            [blockTypes.TREE_LEAVES]: new BABYLON.Color3(0.15, 0.3, 0.1), // Mörkare grön för löv
            [blockTypes.FLOWER_RED]: new BABYLON.Color3(0.8, 0.2, 0.2),
            [blockTypes.FLOWER_YELLOW]: new BABYLON.Color3(0.9, 0.8, 0.2),
            [blockTypes.FLOWER_PURPLE]: new BABYLON.Color3(0.5, 0.2, 0.5),
            [blockTypes.MUSHROOM]: new BABYLON.Color3(0.8, 0.4, 0.4),
            [blockTypes.STONE_SPECIAL]: new BABYLON.Color3(0.5, 0.5, 0.55),
            [blockTypes.MOSS]: new BABYLON.Color3(0.3, 0.45, 0.2),
            [blockTypes.CLOUD]: new BABYLON.Color3(1, 1, 1),
            [blockTypes.SUN]: new BABYLON.Color3(0.9, 0.7, 0.1),
            [blockTypes.DIAMOND]: new BABYLON.Color3(0.2, 0.8, 0.8)
        };
        
        let blockCount = 0;
        const blockMeshes = {};
        const blockMaterials = {};
        
        // Lägg till variabel för att hålla koll på antal diamanter
        let collectedDiamonds = 0;
        
        // Globala variabler i början av script-taggen
        let playerPosition = new BABYLON.Vector3(SPAWN_X, SPAWN_HEIGHT, SPAWN_Z);
        
        // Uppdatera ljudhanteringen i början av script-taggen
        const diamondSound = new Audio('src/sound/diamond.mp3');
        const introSound = new Audio('src/sound/intro.mp3');
        const startSound = new Audio('src/sound/start.mp3');
        const digSound = new Audio('src/sound/dig.mp3');
        const buildSound = new Audio('src/sound/build.mp3');

        // Säkerställ att ljuden är laddade
        introSound.load();
        startSound.load();
        
        function debugLog(message) {
            const timestamp = new Date().toLocaleTimeString();
            const fullMessage = `${timestamp}: ${message}`;
            console.log(fullMessage);
            const debugElement = document.getElementById('debug');
            if (debugElement) {
                debugElement.innerHTML = fullMessage + '<br>' + debugElement.innerHTML;
                if (debugElement.innerHTML.split('<br>').length > 20) {
                    debugElement.innerHTML = debugElement.innerHTML.split('<br>').slice(0, 20).join('<br>');
                }
            }
        }
        
        // Blockera specifika felmeddelanden
        const originalConsoleError = console.error;
        console.error = function() {
            const errorMessage = Array.from(arguments).join(' ');
            if (errorMessage.includes('moz-extension') || 
                errorMessage.includes('Receiving end does not exist') ||
                errorMessage.includes('PHANTOM') ||
                errorMessage.includes('contentScript.js') ||
                errorMessage.includes('solanaActionsContentScript.js') ||
                errorMessage.includes('WEBGL_debug_renderer_info')) {
                return;
            }
            debugLog('ERROR: ' + errorMessage);
            originalConsoleError.apply(console, arguments);
        };
        
        // Hantera fel från Phantom extension
        window.onerror = function(message, source) {
            if (source && (source.includes('moz-extension') || 
                          source.includes('PHANTOM') || 
                          source.includes('contentScript.js') || 
                          source.includes('solanaActionsContentScript.js'))) {
                return true;
            }
        };
        
        // Hantera unhandled promise rejections
        window.onunhandledrejection = function(event) {
            if (event.reason && event.reason.message && 
                (event.reason.message.includes('moz-extension') || 
                 event.reason.message.includes('Receiving end does not exist') ||
                 event.reason.message.includes('PHANTOM'))) {
                event.preventDefault();
            }
        };
        
        // Uppdatera laddningsindikator
        function updateLoadingProgress(progress, text) {
            const progressBar = document.getElementById('loadingProgress');
            const loadingText = document.getElementById('loadingText');
            if (progressBar) {
                progressBar.style.width = `${progress}%`;
            }
            if (loadingText && text) {
                loadingText.textContent = text;
            }
        }

        // Dölj laddningsskärm
        function hideLoadingScreen() {
            const loadingScreen = document.getElementById('loadingScreen');
            if (loadingScreen) {
                loadingScreen.style.display = 'none';
            }
        }

        // Lägg till startknapphantering
        document.addEventListener('DOMContentLoaded', function() {
            document.getElementById('startButton').addEventListener('click', function() {
                // Dölj startskärmen
                document.getElementById('startScreen').style.display = 'none';
                // Visa laddningsskärmen
                document.getElementById('loadingScreen').style.display = 'block';
                // Spela intro-ljudet
                introSound.play().catch(error => {
                    console.error("Kunde inte spela intro-ljudet:", error);
                    debugLog("Ljudfel: " + error.message);
                });
                // Starta spelet
                startGame();
            });
        });
        
        // Flytta all existerande spelinitiering till en ny funktion
        async function startGame() {
            try {
                debugLog('=== STARTING WORLD GENERATION ===');
                
                const canvas = document.getElementById('renderCanvas');
                const engine = new BABYLON.Engine(canvas, true);
                const scene = new BABYLON.Scene(engine);
                
                // Lägg till pointer lock variabel
                let isLocked = false;
                
                // Ljusblå sommarhimmel
                scene.clearColor = new BABYLON.Color4(0.6, 0.8, 1.0, 1.0);
                scene.ambientColor = new BABYLON.Color3(1, 1, 1);
                scene.useRightHandedSystem = true;
                scene.constantlyUpdateMeshUnderPointer = true;
                
                // Uppdatera alpha mode för bättre rendering
                scene.alphaMode = BABYLON.Engine.ALPHA_PREMULTIPLIED;
                
                // Aktivera fysik och kollisioner
                scene.collisionsEnabled = true;
                scene.gravity = new BABYLON.Vector3(0, -9.81, 0);
                
                // Skapa starkt solljus för en sommardag
                const light = new BABYLON.HemisphericLight(
                    "sunLight",
                    new BABYLON.Vector3(0.2, 1, 0.3),
                    scene
                );
                light.intensity = 1.2;
                light.groundColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                
                // Uppdatera dimman för bättre synlighet och himmelsfärg
                scene.fogMode = BABYLON.Scene.FOGMODE_EXP;
                scene.fogDensity = 0.01;
                scene.fogColor = new BABYLON.Color3(0.6, 0.8, 1.0);
                
                debugLog('Miljö skapad');
                
                // Skapa kameran
                const camera = new BABYLON.UniversalCamera("camera", new BABYLON.Vector3(SPAWN_X, baseHeight + 2, SPAWN_Z), scene);
                camera.setTarget(new BABYLON.Vector3(SPAWN_X + 1, SPAWN_HEIGHT + 2, SPAWN_Z + 1));
                camera.attachControl(canvas, true);
                camera.speed = 0.4;
                camera.fov = 1.2;
                camera.checkCollisions = true;
                camera.applyGravity = true;
                camera.ellipsoid = new BABYLON.Vector3(0.4, 1.8, 0.4);
                camera.ellipsoidOffset = new BABYLON.Vector3(0, 0.9, 0);
                camera.minZ = 0.05;
                camera.maxZ = 1000;
                camera.inertia = 0.5;
                camera.angularSensibility = 1000;
                camera.stepHeight = 1.1;

                // Uppdatera kamerans position och spelarposition
                scene.registerBeforeRender(() => {
                    playerPosition.copyFrom(camera.position);
                });
                
                // Sätt upp kontroller för WASD och piltangenter
                const keysForward = [87, 38];  // W och pil upp
                const keysBackward = [83, 40]; // S och pil ner
                const keysLeft = [65, 37];     // A och pil vänster 
                const keysRight = [68, 39];    // D och pil höger

                camera.keysUp = keysForward;
                camera.keysDown = keysBackward;
                camera.keysLeft = keysLeft;
                camera.keysRight = keysRight;

                // Sätt gravitationen för scenen
                scene.gravity = new BABYLON.Vector3(0, -0.65, 0);
                scene.collisionsEnabled = true;
                
                // Hantera hopp
                let canJump = true;
                let jumpVelocity = 0;
                window.addEventListener('keydown', function(evt) {
                    if (evt.code === 'Space' && canJump) {
                        jumpVelocity = 1.0;  // Sätt hopphastighet
                        canJump = false;
                        setTimeout(() => { canJump = true; }, 500);
                    }
                });

                // Uppdatera hopp och gravitation varje frame
                scene.registerBeforeRender(function() {
                    if (jumpVelocity > 0) {
                        camera.position.y += jumpVelocity;
                        jumpVelocity -= 0.05;  // Minska hopphastigheten gradvis
                    }
                });
                
                // Skapa hotbar med block-typer
                const hotbar = document.getElementById('hotbar');
                let selectedBlockType = blockTypes.DIRT; // Standard block-typ
                const crosshair = document.getElementById('crosshair');
                let isCmdPressed = false;

                // Lyssna på CMD-tangenten
                window.addEventListener('keydown', function(evt) {
                    if (evt.metaKey) {  // metaKey är CMD på Mac
                        isCmdPressed = true;
                        // Ändra crosshair-färgen till den valda blocktypen
                        const color = blockColors[selectedBlockType];
                        crosshair.style.color = `rgb(${color.r * 255}, ${color.g * 255}, ${color.b * 255})`;
                    }
                });

                window.addEventListener('keyup', function(evt) {
                    if (evt.key === 'Meta') {  // Meta är CMD på Mac
                        isCmdPressed = false;
                        crosshair.style.color = 'white';  // Återställ till vit
                    }
                });

                // Lägg till block-typer i hotbar
                const hotbarBlocks = [
                    blockTypes.DIRT,
                    blockTypes.GRASS,
                    blockTypes.STONE,
                    blockTypes.TREE_TRUNK
                ];
                
                hotbarBlocks.forEach((type, index) => {
                    const item = document.createElement('div');
                    item.className = 'hotbar-item';
                    
                    // Sätt textur baserat på blocktyp
                    switch(type) {
                        case blockTypes.DIRT:
                            item.style.backgroundImage = 'url("src/textures/dirt.png")';
                            break;
                        case blockTypes.GRASS:
                            item.style.backgroundImage = 'url("src/textures/grass.png")';
                            break;
                        case blockTypes.STONE:
                            item.style.backgroundImage = 'url("src/textures/stone.png")';
                            break;
                        case blockTypes.TREE_TRUNK:
                            item.style.backgroundImage = 'url("src/textures/tree2.png")';
                            break;
                        default:
                            item.style.backgroundColor = `rgb(${blockColors[type].r * 255}, ${blockColors[type].g * 255}, ${blockColors[type].b * 255})`;
                    }
                    
                    if (type === selectedBlockType) {
                        item.classList.add('selected');
                    }
                    
                    item.addEventListener('click', () => {
                        document.querySelectorAll('.hotbar-item').forEach(i => i.classList.remove('selected'));
                        item.classList.add('selected');
                        selectedBlockType = type;
                    });
                    
                    hotbar.appendChild(item);
                    
                    // Lägg till nummer-tangent som genväg (1-6)
                    window.addEventListener('keydown', (event) => {
                        if (event.key === String(index + 1)) {
                            document.querySelectorAll('.hotbar-item').forEach(i => i.classList.remove('selected'));
                            item.classList.add('selected');
                            selectedBlockType = type;
                        }
                    });
                });
                
                // Uppdatera musklickhanteringen
                scene.onPointerDown = function(evt) {
                    if (!isLocked) {
                        canvas.requestPointerLock = canvas.requestPointerLock || 
                                                  canvas.mozRequestPointerLock || 
                                                  canvas.webkitRequestPointerLock;
                        if (canvas.requestPointerLock) {
                            canvas.requestPointerLock();
                        }
                        return;
                    }
                    
                    const pickResult = scene.pick(
                        canvas.width / 2,
                        canvas.height / 2,
                        (mesh) => mesh.checkCollisions,
                        false,
                        camera
                    );
                    
                    if (evt.button === 0) { // Vänsterklick
                        if (!isCmdPressed) {  // Normal blockhantering
                            if (pickResult.hit && pickResult.pickedMesh && pickResult.pickedMesh.blockType) {
                                const position = pickResult.pickedMesh.position;
                                const key = `${Math.floor(position.x)},${Math.floor(position.y)},${Math.floor(position.z)}`;
                                
                                // Om det är en diamant, samla in den och spela diamantljudet
                                if (blockMeshes[key] && blockMeshes[key].blockType === blockTypes.DIAMOND) {
                                    blockMeshes[key].dispose();
                                    delete blockMeshes[key];
                                    collectedDiamonds++;
                                    document.getElementById('diamondCount').textContent = collectedDiamonds;
                                    debugLog(`Diamant samlad! Totalt: ${collectedDiamonds}`);
                                    
                                    // Spela upp diamantljudet
                                    diamondSound.currentTime = 0;
                                    diamondSound.play().catch(error => {
                                        console.log("Kunde inte spela ljudet:", error);
                                    });
                                } else {
                                    // Vanlig blockborttagning för andra block
                                    blockMeshes[key].dispose();
                                    delete blockMeshes[key];
                                    debugLog(`Block borttaget på ${key}`);
                                    
                                    // Spela upp grävljudet
                                    digSound.currentTime = 0;
                                    digSound.play().catch(error => {
                                        console.log("Kunde inte spela ljudet:", error);
                                    });
                                }
                            }
                        } else if (pickResult.hit) {  // Placera block om CMD är intryckt
                            const point = pickResult.pickedPoint;
                            const normal = pickResult.getNormal();
                            
                            // Beräkna den nya blockpositionen med bättre precision
                            const epsilon = 0.001;  // Liten offset för att undvika z-fighting
                            const newX = Math.round(point.x + normal.x * (0.5 + epsilon));
                            const newY = Math.round(point.y + normal.y * (0.5 + epsilon));
                            const newZ = Math.round(point.z + normal.z * (0.5 + epsilon));
                            
                            // Kontrollera avståndet till spelaren
                            const playerPos = camera.position;
                            const distanceToPlayer = BABYLON.Vector3.Distance(
                                new BABYLON.Vector3(newX, newY, newZ),
                                playerPos
                            );
                            
                            // Kontrollera att blocket inte är för nära eller för långt bort
                            if (distanceToPlayer > 1.5 && distanceToPlayer < 5) {
                                const playerBlockPos = {
                                    x: Math.round(playerPos.x),
                                    y: Math.round(playerPos.y),
                                    z: Math.round(playerPos.z)
                                };
                                
                                const playerHeadPos = {
                                    x: Math.round(playerPos.x),
                                    y: Math.round(playerPos.y + 1),
                                    z: Math.round(playerPos.z)
                                };
                                
                                // Kontrollera att vi inte placerar block där spelaren står
                                if (!(newX === playerBlockPos.x && newY === playerBlockPos.y && newZ === playerBlockPos.z) &&
                                    !(newX === playerHeadPos.x && newY === playerHeadPos.y && newZ === playerHeadPos.z)) {
                                    createBlock(newX, newY, newZ, selectedBlockType);
                                    debugLog(`Block placerat på ${newX},${newY},${newZ}`);
                                    
                                    // Spela upp byggljudet
                                    buildSound.currentTime = 0;
                                    buildSound.play().catch(error => {
                                        console.log("Kunde inte spela ljudet:", error);
                                    });
                                }
                            }
                        }
                    }
                };
                
                // Förhindra standardhögerklick-menyn
                canvas.addEventListener('contextmenu', function(evt) {
                    evt.preventDefault();
                });
                
                // Lyssna på pointer lock ändringar
                document.addEventListener("pointerlockchange", lockChangeAlert, false);
                document.addEventListener("mozpointerlockchange", lockChangeAlert, false);
                document.addEventListener("webkitpointerlockchange", lockChangeAlert, false);
                
                function lockChangeAlert() {
                    isLocked = document.pointerLockElement === canvas ||
                              document.mozPointerLockElement === canvas ||
                              document.webkitPointerLockElement === canvas;
                    
                    if (isLocked) {
                        debugLog("Muspekare låst");
                        camera.attachControl(canvas, true);
                        document.getElementById('crosshair').style.display = 'block';
                    } else {
                        debugLog("Muspekare frigjord");
                        moveForward = moveBackward = moveLeft = moveRight = false;
                        camera.detachControl(canvas);
                        document.getElementById('crosshair').style.display = 'none';
                    }
                }
                
                // Hantera ESC-tangenten för att frigöra muspekaren
                window.addEventListener("keydown", function(evt) {
                    if (evt.keyCode === 27) { // ESC
                        if (isLocked) {
                            document.exitPointerLock = document.exitPointerLock ||
                                                     document.mozExitPointerLock ||
                                                     document.webkitExitPointerLock;
                            if (document.exitPointerLock) {
                                document.exitPointerLock();
                            }
                        }
                    }
                });
                
                // Funktion för att skapa ett block
                function createBlock(x, y, z, type) {
                    const key = `${x},${y},${z}`;
                    
                    const box = BABYLON.MeshBuilder.CreateBox(
                        `block_${key}`,
                        { size: 1 },
                        scene
                    );
                    box.position = new BABYLON.Vector3(x, y, z);
                    box.checkCollisions = true;
                    box.isPickable = true;
                    
                    // Skapa eller återanvänd material
                    let materialKey = `material_${type}`;
                    
                    let material;
                    
                    if (!blockMaterials[materialKey]) {
                        material = new BABYLON.StandardMaterial(materialKey, scene);
                        material.diffuseColor = blockColors[type];
                        material.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                        material.useDepthPassForTransparentRendering = true;

                        // Specialhantering för solen
                        if (type === blockTypes.SUN) {
                            const sunTexture = new BABYLON.Texture("src/textures/sun.png", scene);
                            material.diffuseTexture = sunTexture;
                            material.diffuseTexture.hasAlpha = false;
                            material.backFaceCulling = false;
                            material.emissiveColor = new BABYLON.Color3(0.4, 0.3, 0);
                            material.ambientColor = new BABYLON.Color3(0.9, 0.7, 0.1);
                            material.specularColor = new BABYLON.Color3(0.3, 0.3, 0);
                            sunTexture.onLoadObservable.add(() => {
                                material.markAsDirty(BABYLON.Material.TextureDirtyFlag);
                            });
                        }

                        // Specialhantering för blommor
                        if (type === blockTypes.FLOWER_RED || type === blockTypes.FLOWER_YELLOW || type === blockTypes.FLOWER_PURPLE) {
                            const flowerTexture = new BABYLON.Texture(
                                type === blockTypes.FLOWER_PURPLE ? "src/textures/flower2.png" : "src/textures/flower.png",
                                scene
                            );
                            material.diffuseTexture = flowerTexture;
                            material.diffuseTexture.hasAlpha = false;
                            material.transparencyMode = BABYLON.Material.MATERIAL_OPAQUE;
                            material.backFaceCulling = true;
                            material.specularColor = new BABYLON.Color3(0, 0, 0);
                            material.ambientColor = blockColors[type];
                            material.alpha = 1.0;
                            flowerTexture.onLoadObservable.add(() => {
                                material.markAsDirty(BABYLON.Material.TextureDirtyFlag);
                            });
                        }

                        // Lägg till gräs-textur
                        if (type === blockTypes.GRASS) {
                            const grassTexture = new BABYLON.Texture("src/textures/grass.png", scene);
                            material.diffuseTexture = grassTexture;
                            material.diffuseTexture.hasAlpha = false;
                            material.backFaceCulling = false;
                            material.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                            material.ambientColor = new BABYLON.Color3(0.35, 0.6, 0.25);
                            material.emissiveColor = new BABYLON.Color3(0.05, 0.1, 0.02);
                        }

                        // Lägg till sten-textur
                        if (type === blockTypes.STONE || type === blockTypes.STONE_SPECIAL) {
                            const stoneTexture = new BABYLON.Texture("src/textures/stone.png", scene);
                            material.diffuseTexture = stoneTexture;
                            material.diffuseTexture.hasAlpha = false;
                            material.backFaceCulling = false;
                            material.specularColor = new BABYLON.Color3(0.2, 0.2, 0.2);
                            material.ambientColor = new BABYLON.Color3(0.6, 0.6, 0.6);
                            stoneTexture.onLoadObservable.add(() => {
                                material.markAsDirty(BABYLON.Material.TextureDirtyFlag);
                            });
                        }
                        
                        // Lägg till textur för trädens löv
                        if (type === blockTypes.TREE_LEAVES) {
                            const leavesTexture = new BABYLON.Texture("src/textures/tree.png", scene);
                            material.diffuseTexture = leavesTexture;
                            material.diffuseTexture.hasAlpha = false;  // Ingen alpha
                            material.transparencyMode = BABYLON.Material.MATERIAL_OPAQUE;  // Helt ogenomskinligt
                            material.backFaceCulling = true;
                            material.specularColor = new BABYLON.Color3(0, 0, 0);
                            material.ambientColor = new BABYLON.Color3(0.4, 0.6, 0.3);
                            material.emissiveColor = new BABYLON.Color3(0.1, 0.15, 0.05);
                            material.alpha = 1.0;
                            leavesTexture.onLoadObservable.add(() => {
                                material.markAsDirty(BABYLON.Material.TextureDirtyFlag);
                            });
                        }
                        
                        // Uppdatera barktextur för trädstammar
                        if (type === blockTypes.TREE_TRUNK) {
                            const isAlternativeTexture = materialKey.endsWith('_v2');
                            const barkTexture = new BABYLON.Texture(
                                isAlternativeTexture ? "src/textures/tree3.png" : "src/textures/tree2.png",
                                scene
                            );
                            material.diffuseTexture = barkTexture;
                            material.diffuseTexture.hasAlpha = false;
                            material.backFaceCulling = false;
                            material.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                            material.ambientColor = new BABYLON.Color3(0.6, 0.4, 0.2);
                            material.emissiveColor = new BABYLON.Color3(0.1, 0.05, 0);
                        }
                        
                        // Hantera genomskinliga block
                        if (type === blockTypes.CLOUD) {
                            material = new BABYLON.StandardMaterial(`cloudMaterial_${key}`, scene);
                            material.diffuseColor = new BABYLON.Color3(1, 1, 1);
                            material.alpha = 0.3;
                            material.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;
                            material.backFaceCulling = false;
                            material.specularColor = new BABYLON.Color3(0, 0, 0);
                            material.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                            material.useAlphaFromDiffuseTexture = true;
                        }
                        
                        // Gör blommor och svampar delvis genomskinliga
                        if (type === blockTypes.MUSHROOM) {
                            material.alpha = 0.8;
                            material.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;
                            material.separateCullingPass = true;
                            material.backFaceCulling = false;
                        }
                        
                        // Uppdatera materialhanteringen för dirt
                        if (type === blockTypes.DIRT) {
                            const dirtTexture = new BABYLON.Texture("src/textures/dirt.png", scene);
                            material.diffuseTexture = dirtTexture;
                            material.diffuseTexture.hasAlpha = false;
                            material.backFaceCulling = false;
                            material.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                            material.ambientColor = new BABYLON.Color3(0.35, 0.25, 0.15);
                            material.emissiveColor = new BABYLON.Color3(0.05, 0.03, 0.02);
                            dirtTexture.onLoadObservable.add(() => {
                                material.markAsDirty(BABYLON.Material.TextureDirtyFlag);
                            });
                        }
                        
                        // Lägg till diamond-textur
                        if (type === blockTypes.DIAMOND) {
                            const diamondTexture = new BABYLON.Texture("src/textures/diamond.png", scene);
                            material.diffuseTexture = diamondTexture;
                            material.diffuseTexture.hasAlpha = false;
                            material.backFaceCulling = false;
                            material.specularColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                            material.ambientColor = new BABYLON.Color3(0.2, 0.8, 0.8);
                            material.emissiveColor = new BABYLON.Color3(0.1, 0.3, 0.3);
                            diamondTexture.onLoadObservable.add(() => {
                                material.markAsDirty(BABYLON.Material.TextureDirtyFlag);
                            });
                        }
                        
                        blockMaterials[materialKey] = material;
                    } else {
                        material = blockMaterials[materialKey];
                    }
                    
                    box.material = material;
                    box.blockType = type;
                    
                    // Uppdatera renderingsgrupper för olika blocktyper
                    if (type === blockTypes.TREE_LEAVES || type === blockTypes.TREE_TRUNK) {
                        box.renderingGroupId = 0;  // Samma renderingsgrupp som andra block
                    } else if (type === blockTypes.CLOUD) {
                        box.renderingGroupId = 1;
                    } else if (type === blockTypes.SUN) {
                        box.renderingGroupId = 0;
                    } else {
                        box.renderingGroupId = 0;
                    }
                    
                    blockMeshes[key] = box;
                    blockCount++;
                    
                    return box;
                }
                
                // Uppdatera createTree-funktionen för att använda samma bark för hela trädet
                function createTree(x, y, z) {
                    const height = 5 + Math.floor(Math.random() * 3); // Trädhöjd 5-7 block
                    
                    // Kontrollera om platsen är ledig för ett träd
                    for (let i = 0; i < height; i++) {
                        const key = `${x},${y + i},${z}`;
                        if (blockMeshes[key]) {
                            return false; // Platsen är upptagen
                        }
                    }
                    
                    // Bestäm vilken bark-textur detta träd ska använda
                    const useAlternativeBark = Math.random() < 0.5;
                    const barkMaterialKey = `material_${blockTypes.TREE_TRUNK}_${useAlternativeBark ? 'v2' : 'v1'}`;
                    
                    // Skapa stam med samma bark-textur
                    for (let i = 0; i < height; i++) {
                        const trunkBlock = BABYLON.MeshBuilder.CreateBox(
                            `block_${x},${y + i},${z}`,
                            { size: 1 },
                            scene
                        );
                        trunkBlock.position = new BABYLON.Vector3(x, y + i, z);
                        trunkBlock.checkCollisions = true;
                        trunkBlock.isPickable = true;
                        
                        // Återanvänd eller skapa material för denna bark-typ
                        let material;
                        if (!blockMaterials[barkMaterialKey]) {
                            material = new BABYLON.StandardMaterial(barkMaterialKey, scene);
                            material.diffuseColor = blockColors[blockTypes.TREE_TRUNK];
                            material.specularColor = new BABYLON.Color3(0.1, 0.1, 0.1);
                            material.ambientColor = new BABYLON.Color3(0.6, 0.4, 0.2);
                            material.emissiveColor = new BABYLON.Color3(0.1, 0.05, 0);
                            
                            const barkTexture = new BABYLON.Texture(
                                useAlternativeBark ? "src/textures/tree3.png" : "src/textures/tree2.png",
                                scene
                            );
                            material.diffuseTexture = barkTexture;
                            material.diffuseTexture.hasAlpha = false;
                            material.backFaceCulling = false;
                            
                            blockMaterials[barkMaterialKey] = material;
                        } else {
                            material = blockMaterials[barkMaterialKey];
                        }
                        
                        trunkBlock.material = material;
                        trunkBlock.blockType = blockTypes.TREE_TRUNK;
                        trunkBlock.renderingGroupId = 0;
                        
                        const key = `${x},${y + i},${z}`;
                        blockMeshes[key] = trunkBlock;
                        blockCount++;
                    }
                    
                    // Skapa lövverk (som tidigare)
                    const leafStart = height - 4;
                    
                    for (let dy = 0; dy < 5; dy++) {
                        const radius = dy === 1 || dy === 2 || dy === 3 ? 2 : 1;
                        
                        for (let dx = -radius; dx <= radius; dx++) {
                            for (let dz = -radius; dz <= radius; dz++) {
                                if (Math.abs(dx) <= radius && Math.abs(dz) <= radius) {
                                    const leafX = x + dx;
                                    const leafY = y + leafStart + dy;
                                    const leafZ = z + dz;
                                    
                                    if (Math.random() > 0.05) {
                                        const leafKey = `${leafX},${leafY},${leafZ}`;
                                        if (!blockMeshes[leafKey]) {
                                            createBlock(leafX, leafY, leafZ, blockTypes.TREE_LEAVES);
                                        }
                                    }
                                }
                            }
                        }
                    }
                    
                    return true;
                }
                
                // Hjälpfunktion för att skapa en blomma
                function createFlower(x, y, z) {
                    const random = Math.random();
                    const type = random < 0.33 ? blockTypes.FLOWER_RED : 
                                random < 0.66 ? blockTypes.FLOWER_YELLOW :
                                blockTypes.FLOWER_PURPLE;
                    createBlock(x, y, z, type);
                }
                
                // Hjälpfunktion för att skapa en svamp
                function createMushroom(x, y, z) {
                    createBlock(x, y, z, blockTypes.MUSHROOM);
                }
                
                // Uppdatera createCloud-funktionen
                function createCloud(centerX, centerY, centerZ) {
                    const cloudSize = 3 + Math.floor(Math.random() * 4);
                    const cloudHeight = 1 + Math.floor(Math.random() * 2);
                    
                    for (let y = 0; y < cloudHeight; y++) {
                        for (let x = -cloudSize; x <= cloudSize; x++) {
                            for (let z = -cloudSize; z <= cloudSize; z++) {
                                if (x*x + z*z <= cloudSize*cloudSize) {
                                    if (Math.random() < 0.7) {
                                        const cloudX = centerX + x;
                                        const cloudY = centerY + y;
                                        const cloudZ = centerZ + z;
                                        const key = `${cloudX},${cloudY},${cloudZ}`;
                                        
                                        if (!blockMeshes[key]) {
                                            const cloudBlock = createBlock(cloudX, cloudY, cloudZ, blockTypes.CLOUD);
                                            // Uppdatera molnens material
                                            const cloudMaterial = new BABYLON.StandardMaterial(`cloudMaterial_${key}`, scene);
                                            cloudMaterial.diffuseColor = new BABYLON.Color3(1, 1, 1);
                                            cloudMaterial.alpha = 0.3;
                                            cloudMaterial.transparencyMode = BABYLON.Material.MATERIAL_ALPHABLEND;
                                            cloudMaterial.backFaceCulling = false;
                                            cloudMaterial.specularColor = new BABYLON.Color3(0, 0, 0);
                                            cloudMaterial.emissiveColor = new BABYLON.Color3(0.5, 0.5, 0.5);
                                            cloudMaterial.useAlphaFromDiffuseTexture = true;
                                            cloudMaterial.separateCullingPass = true;
                                            cloudBlock.material = cloudMaterial;
                                            cloudBlock.renderingGroupId = 2; // Ändra till högre renderingsgrupp
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Uppdatera createSun-funktionen för att använda faktiska 2x2x2 block
                function createSun(x, y, z) {
                    // Skapa en 2x2x2 sol med separata block
                    for (let dx = 0; dx < 2; dx++) {
                        for (let dy = 0; dy < 2; dy++) {
                            for (let dz = 0; dz < 2; dz++) {
                                createBlock(x + dx, y + dy, z + dz, blockTypes.SUN);
                            }
                        }
                    }
                }
                
                // Funktion för att placera diamanter
                function placeDiamonds() {
                    const size = 16;
                    let diamondsPlaced = 0;
                    const MAX_TREE_HEIGHT = 12; // Maxhöjd för träd (baserat på trädhöjd 5-7 + lövverk)
                    
                    while (diamondsPlaced < 10) {
                        const x = -size + Math.floor(Math.random() * size * 2);
                        const z = -size + Math.floor(Math.random() * size * 2);
                        
                        // Hitta högsta blocket på denna position
                        let maxHeight = 0;
                        for (let checkY = 0; checkY < MAX_TREE_HEIGHT; checkY++) {
                            const key = `${x},${checkY},${z}`;
                            if (blockMeshes[key]) {
                                maxHeight = checkY;
                            }
                        }
                        
                        if (maxHeight > 0) {
                            // Slumpmässigt välj om diamanten ska vara på marken eller på sten
                            const placement = Math.random();
                            let y = maxHeight + 1;
                            
                            if (placement < 0.5) {
                                // På marken/sten - använd current height
                                y = maxHeight + 1;
                            } else {
                                // På toppen av sten - leta efter stenblock
                                for (let checkY = maxHeight; checkY > 0; checkY--) {
                                    const key = `${x},${checkY},${z}`;
                                    if (blockMeshes[key] && blockMeshes[key].blockType === blockTypes.STONE) {
                                        y = checkY + 1;
                                        break;
                                    }
                                }
                            }
                            
                            // Kontrollera att vi inte placerar diamanten för högt
                            if (y <= MAX_TREE_HEIGHT) {
                                // Placera diamanten om positionen är ledig
                                const key = `${x},${y},${z}`;
                                if (!blockMeshes[key]) {
                                    createBlock(x, y, z, blockTypes.DIAMOND);
                                    diamondsPlaced++;
                                    debugLog(`Diamant placerad på ${x},${y},${z}`);
                                }
                            }
                        }
                    }
                }
                
                // Generera terräng för världen
                debugLog('Creating world...');
                
                // Använd Simplex noise för att generera naturlig terräng
                function noise(x, z) {
                    return Math.sin(x * 0.1) * Math.cos(z * 0.1) * 2 + 
                           Math.sin(x * 0.05 + z * 0.05) * 3;
                }
                
                // Skapa terräng med träd och växter
                async function generateForest() {
                    const size = 16;
                    
                    // Skapa solen först, placera den högre upp
                    createSun(-10, 45, -10);
                    
                    // Skapa några moln på himlen, placera dem högre upp
                    for (let i = 0; i < 8; i++) {
                        const cloudX = -size + Math.floor(Math.random() * size * 2);
                        const cloudZ = -size + Math.floor(Math.random() * size * 2);
                        const cloudY = 35 + Math.floor(Math.random() * 5);
                        createCloud(cloudX, cloudY, cloudZ);
                    }
                    
                    // Först skapar vi terrängen
                    for (let x = -size; x <= size; x++) {
                        for (let z = -size; z <= size; z++) {
                            const height = Math.floor(baseHeight + noise(x, z));
                            
                            // Skapa markblock
                            for (let y = 0; y <= height; y++) {
                                const blockType = y === height ? blockTypes.GRASS :
                                                y > height - 3 ? blockTypes.DIRT :
                                                blockTypes.STONE;
                                createBlock(x, y, z, blockType);
                            }
                            
                            // Placera träd
                            if (Math.random() < 0.05 && Math.abs(x) > 3 && Math.abs(z) > 3) {
                                let canPlaceTree = true;
                                for (let dx = -2; dx <= 2; dx++) {
                                    for (let dz = -2; dz <= 2; dz++) {
                                        const nearbyKey = `${x + dx},${height + 1},${z + dz}`;
                                        if (blockMeshes[nearbyKey]) {
                                            canPlaceTree = false;
                                            break;
                                        }
                                    }
                                }
                                if (canPlaceTree) {
                                    createTree(x, height + 1, z);
                                }
                            }
                            
                            // Placera blommor
                            if (Math.random() < 0.03) {
                                createFlower(x, height + 1, z);
                            }
                            
                            // Placera stenformationer
                            if (Math.random() < 0.02 && Math.abs(x) > 2 && Math.abs(z) > 2) {
                                let canPlaceStone = true;
                                for (let dx = -2; dx <= 2; dx++) {
                                    for (let dz = -2; dz <= 2; dz++) {
                                        const nearbyKey = `${x + dx},${height + 1},${z + dz}`;
                                        if (blockMeshes[nearbyKey]) {
                                            canPlaceStone = false;
                                            break;
                                        }
                                    }
                                }
                                if (canPlaceStone) {
                                    createStoneFormation(x, height + 1, z);
                                }
                            }
                            
                            await new Promise(resolve => setTimeout(resolve, 10));
                            scene.render();
                        }
                        
                        const progress = ((x + size) / (size * 2)) * 100;
                        updateLoadingProgress(progress, `Generating world... ${Math.round(progress)}%`);
                    }
                    
                    // Placera diamanter efter att världen är genererad
                    placeDiamonds();
                    
                    // Stoppa intro-ljudet när världen är färdigladdad
                    introSound.pause();
                    introSound.currentTime = 0;
                }
                
                // Lägg till funktion för att skapa stenformationer
                function createStoneFormation(x, y, z) {
                    const height = 2 + Math.floor(Math.random() * 3); // Höjd 2-4 block
                    const width = 2 + Math.floor(Math.random() * 2);  // Bredd 2-3 block
                    
                    for (let dy = 0; dy < height; dy++) {
                        const currentWidth = Math.max(1, width - Math.floor(dy/2)); // Smalare högre upp
                        for (let dx = -currentWidth; dx <= currentWidth; dx++) {
                            for (let dz = -currentWidth; dz <= currentWidth; dz++) {
                                // Skapa en mer naturlig, oregelbunden form
                                if (dx*dx + dz*dz <= currentWidth*currentWidth + 0.5) {
                                    if (Math.random() > 0.2) { // 80% chans att placera block
                                        createBlock(x + dx, y + dy, z + dz, blockTypes.STONE);
                                    }
                                }
                            }
                        }
                    }
                }
                
                // Generera världen
                await generateForest();
                debugLog('World created!');
                
                // Starta renderingsloopen
                engine.runRenderLoop(function() {
                scene.render();
            });
            
                // Dölj laddningsskärmen och spela start-ljudet
                hideLoadingScreen();
                
                // Spela start-ljudet med en liten fördröjning för att säkerställa att intro-ljudet är klart
                setTimeout(() => {
                    startSound.play().catch(error => {
                        console.error("Kunde inte spela start-ljudet:", error);
                        debugLog("Ljudfel: " + error.message);
                    });
                }, 500);
                
                window.addEventListener('resize', function() {
                engine.resize();
            });
                
                // Add this after scene creation
                engine.setHardwareScalingLevel(1.0);
                engine.cullBackFaces = true;
                engine.setDepthBuffer(true);
                engine.setDepthWrite(true);
                
                // Aktivera depth pre-pass för bättre z-sortering
                scene.enableDepthRenderer();
                
                // Konfigurera renderingsordning
                scene.setRenderingOrder(BABYLON.RenderingGroupInfo.OPAQUE_FIRST);
                
                // Uppdatera renderingsordningen men behåll depth sorting
                scene.setRenderingOrder(BABYLON.RenderingGroupInfo.OPAQUE_FIRST, (a, b) => {
                    // Om ett av objekten är ett moln, prioritera det
                    if (a.blockType === blockTypes.CLOUD) return 1;
                    if (b.blockType === blockTypes.CLOUD) return -1;
                    
                    // Om båda är moln eller inget är moln, sortera efter z-position
                    if (a.renderingGroupId === b.renderingGroupId) {
                        return b.position.z - a.position.z;
                    }
                    return b.renderingGroupId - a.renderingGroupId;
                });
                
                // Behåll depth sorting för transparenta objekt
                scene.needDepthPrePass = true;
                scene.separateTransparentPass = true;
                scene.useOrderIndependentTransparency = true;
                
            } catch (error) {
                debugLog('ERROR: ' + error.message);
                console.error(error);
            }
        }

        // Ta bort den automatiska diamantinsamlingen
        function checkForDiamonds() {
            // Denna funktion behövs inte längre
            return;
        }

        // Lägg till en funktion för att hantera ljuduppspelning
        async function playSound(sound) {
            try {
                await sound.play();
            } catch (error) {
                console.error("Kunde inte spela ljud:", error);
                debugLog("Ljudfel: " + error.message);
            }
        }
    </script>
</body>
</html>